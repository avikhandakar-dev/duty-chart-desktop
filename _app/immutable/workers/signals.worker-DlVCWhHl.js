var H=Object.defineProperty;var J=(d,S,A)=>S in d?H(d,S,{enumerable:!0,configurable:!0,writable:!0,value:A}):d[S]=A;var z=(d,S,A)=>J(d,typeof S!="symbol"?S+"":S,A);(function(){"use strict";const d=n=>n>="0"&&n<="9",S=n=>n>="a"&&n<="z"||n>="A"&&n<="Z"||n==="_"||n==="$";class A{constructor(t){z(this,"pos",0);this.input=t}next(){const t=this.input,e=t.length;for(;this.pos<e&&/\s/.test(t[this.pos]??"");)this.pos++;if(this.pos>=e)return{type:"eof",pos:this.pos};const r=this.pos,i=t[this.pos];if(d(i)||i==="."&&d(t[this.pos+1]??"")){let f=i===".";for(this.pos++;this.pos<e;){const b=t[this.pos];if(d(b))this.pos++;else if(b==="."&&!f)f=!0,this.pos++;else break}return{type:"number",value:t.slice(r,this.pos),pos:r}}if(S(i)){for(this.pos++;this.pos<e;){const v=t[this.pos];if(S(v)||d(v))this.pos++;else break}const f=t.slice(r,this.pos),b=f.toLowerCase();return b==="and"?{type:"and",pos:r}:b==="or"?{type:"or",pos:r}:b==="not"?{type:"not",pos:r}:b==="crossesabove"?{type:"crossesAbove",pos:r}:b==="crossesbelow"?{type:"crossesBelow",pos:r}:{type:"identifier",value:f,pos:r}}switch(this.pos++,i){case">":return t[this.pos]==="="?(this.pos++,{type:"gte",pos:r}):{type:"gt",pos:r};case"<":return t[this.pos]==="="?(this.pos++,{type:"lte",pos:r}):{type:"lt",pos:r};case"=":{if(t[this.pos]==="=")return this.pos++,{type:"eq",pos:r};throw new Error(`Unexpected '=' at ${r}, expected '=='`)}case"!":{if(t[this.pos]==="=")return this.pos++,{type:"neq",pos:r};throw new Error(`Unexpected '!' at ${r}, expected '!='`)}case"(":return{type:"lparen",pos:r};case")":return{type:"rparen",pos:r};case",":return{type:"comma",pos:r};default:throw new Error(`Unexpected character "${i}" at position ${r}`)}}}class L extends Error{constructor(t,e){super(t),this.position=e,this.name="ConditionParseError"}}class B{constructor(t){z(this,"current");this.tokenizer=t,this.current=t.next()}eat(t){if(this.current.type!==t)throw new L(`Expected ${t} but found ${this.current.type}`,this.current.pos);const e=this.current;return this.current=this.tokenizer.next(),e}match(t){return this.current.type===t?(this.current=this.tokenizer.next(),!0):!1}parseCondition(){const t=this.parseOr();if(this.current.type!=="eof")throw new L("Unexpected input after end of condition",this.current.pos);return t}parseOr(){let t=this.parseAnd();for(;this.current.type==="or";){this.eat("or");const e=this.parseAnd();t={kind:"Logical",op:"or",left:t,right:e}}return t}parseAnd(){let t=this.parsePrimary();for(;this.current.type==="and";){this.eat("and");const e=this.parsePrimary();t={kind:"Logical",op:"and",left:t,right:e}}return t}parsePrimary(){if(this.current.type==="lparen"){this.eat("lparen");const t=this.parseOr();return this.eat("rparen"),t}if(this.current.type==="not")return this.eat("not"),{kind:"Negation",expr:this.parsePrimary()};if(this.current.type==="identifier"){const t=this.current,e=String(t.value||""),r=e.toLowerCase();if(this.current=this.tokenizer.next(),this.current.type==="lparen"){this.eat("lparen");const i=[];if(this.current.type!=="rparen")for(;i.push(this.parseValue()),!!this.match("comma"););return this.eat("rparen"),r==="between"&&i.length===3?{kind:"Between",value:i[0],a:i[1],b:i[2]}:{kind:"Call",name:e,args:i}}this.current=t}return this.parseAtomCondition()}parseAtomCondition(){const t=this.parseValue();if(this.current.type==="crossesAbove"||this.current.type==="crossesBelow"){const b=this.current;if(this.current=this.tokenizer.next(),t.kind!=="SeriesRef")throw new L("`crossesAbove/crossesBelow` left side must be a series name",b.pos);const v=this.parseValue();return{kind:"Cross",dir:b.type==="crossesAbove"?"above":"below",left:t,right:v}}if(this.current.type!=="gt"&&this.current.type!=="lt"&&this.current.type!=="gte"&&this.current.type!=="lte"&&this.current.type!=="eq"&&this.current.type!=="neq")return{kind:"Comparison",op:">",left:t,right:{kind:"NumberLiteral",value:0}};const e=this.current;let r;switch(e.type){case"gt":r=">";break;case"lt":r="<";break;case"gte":r=">=";break;case"lte":r="<=";break;case"eq":r="==";break;case"neq":r="==";break;default:r=">";break}this.current=this.tokenizer.next();const i=this.parseValue(),f={kind:"Comparison",op:r,left:t,right:i};return e.type==="neq"?{kind:"Logical",op:"or",left:{kind:"Comparison",op:">",left:t,right:i},right:{kind:"Comparison",op:"<",left:t,right:i}}:f}parseSeriesRef(){if(this.current.type!=="identifier")throw new L("Expected series name",this.current.pos);const t=this.current;return this.current=this.tokenizer.next(),{kind:"SeriesRef",name:t.value||""}}parseValue(){if(this.current.type==="number"){const t=this.current;this.current=this.tokenizer.next();const e=Number(t.value);if(!Number.isFinite(e))throw new L("Invalid number literal",t.pos);return{kind:"NumberLiteral",value:e}}if(this.current.type==="identifier"){const t=this.current;if(this.current=this.tokenizer.next(),this.current.type==="lparen"){this.eat("lparen");const e=[];if(this.current.type!=="rparen")for(;e.push(this.parseValue()),!!this.match("comma"););return this.eat("rparen"),{kind:"ValueCall",name:String(t.value||""),args:e}}return{kind:"SeriesRef",name:String(t.value||"")}}throw new L(`Expected number or identifier but found ${this.current.type}`,this.current.pos)}}function P(n){return new B(new A(n)).parseCondition()}class V extends Error{constructor(t){super(t),this.name="ConditionEngineError"}}function q(n){return n.replace(/\s+/g,"_").toLowerCase()}function g(n,t){const e=q(t),r=n[e];if(!r)throw new V(`Unknown series "${t}" in condition`);return r}function I(n){const t=Object.entries(n);if(!t.length)return 0;const e=t[0][1].length;for(const[,r]of t)if(r.length!==e)throw new V("All series must have the same length");return e}function C(n,t,e){var r,i,f,b,v,F;if(n.kind==="NumberLiteral")return n.value;if(n.kind==="SeriesRef")return g(e,n.name)[t];if(n.kind==="ValueCall"){const a=String(n.name||"").toLowerCase(),s=n.args;if(a==="lowest"||a==="highest"){const c=s[0],o=s[1],h=g(e,c.name||String(c)),u=Math.max(1,Math.floor(o.value??Number(o.name)??1)),m=Math.max(0,t-u+1);let l=a==="lowest"?1/0:-1/0;for(let p=m;p<=t;p++){const w=h[p];Number.isFinite(w)&&(a==="lowest"?l=Math.min(l,w):l=Math.max(l,w))}return Number.isFinite(l)?l:NaN}if(a==="lag"||a==="prev"){const c=s[0],o=s[1],h=g(e,c.name||String(c)),u=Math.max(1,Math.floor((o==null?void 0:o.value)??Number(o==null?void 0:o.name)??1)),m=t-u;return m>=0?h[m]:NaN}if(a==="change"){const c=s[0],o=s[1],h=g(e,c.name||String(c)),u=Math.max(1,Math.floor((o==null?void 0:o.value)??Number(o==null?void 0:o.name)??1)),m=t-u,l=h[t],p=m>=0?h[m]:NaN;return Number.isFinite(l)&&Number.isFinite(p)?l-p:NaN}if(a==="abs"){const c=C(s[0],t,e);return Math.abs(c)}if(a==="add"||a==="sub"||a==="mul"||a==="div"){const c=C(s[0],t,e),o=C(s[1],t,e);return[c,o].every(Number.isFinite)?a==="add"?c+o:a==="sub"?c-o:a==="mul"?c*o:o===0?NaN:c/o:NaN}if(a==="min"||a==="max"){const c=C(s[0],t,e),o=C(s[1],t,e);return[c,o].every(Number.isFinite)?a==="min"?Math.min(c,o):Math.max(c,o):NaN}if(a==="sma"){const c=((r=s[0])==null?void 0:r.name)||String(s[0]),o=((i=s[1])==null?void 0:i.value)??Number((f=s[1])==null?void 0:f.name),h=Math.max(1,Math.floor(Number(o)||0)),u=g(e,c);if(!Number.isFinite(u[t]))return NaN;let m=0,l=0;const p=Math.max(0,t-h+1);for(let w=p;w<=t;w++){const y=u[w];Number.isFinite(y)&&(m+=y,l++)}return l?m/l:NaN}if(a==="ema"){const c=((b=s[0])==null?void 0:b.name)||String(s[0]),o=((v=s[1])==null?void 0:v.value)??Number((F=s[1])==null?void 0:F.name),h=Math.max(1,Math.floor(Number(o)||0)),u=g(e,c),m=2/(h+1);let l;for(let p=0;p<=t;p++){const w=u[p];Number.isFinite(w)&&(l===void 0?l=w:l=w*m+l*(1-m))}return l??NaN}return NaN}return NaN}function R(n,t,e){const r=C(n.left,t,e),i=C(n.right,t,e);if(!Number.isFinite(r)||!Number.isFinite(i))return!1;switch(n.op){case">":return r>i;case"<":return r<i;case">=":return r>=i;case"<=":return r<=i;case"==":return Math.abs(r-i)<1e-9;default:return!1}}function U(n,t,e){if(t===0)return!1;const r=g(e,n.left.name);let i,f;if(n.right.kind==="NumberLiteral")i=n.right.value,f=n.right.value;else{const F=g(e,n.right.name);i=F[t-1],f=F[t]}const b=r[t-1],v=r[t];return!Number.isFinite(b)||!Number.isFinite(i)||!Number.isFinite(v)||!Number.isFinite(f)?!1:n.dir==="above"?b<=i&&v>f:b>=i&&v<f}function _(n,t,e){return n.op==="and"?E(n.left,t,e)&&E(n.right,t,e):E(n.left,t,e)||E(n.right,t,e)}function O(n,t,e){let r=-1/0;for(let i=t;i<=e;i++){const f=n[i];Number.isFinite(f)&&f>r&&(r=f)}return r}function T(n,t,e){let r=1/0;for(let i=t;i<=e;i++){const f=n[i];Number.isFinite(f)&&f<r&&(r=f)}return r}function $(n,t=1){if(!n)return t;if(n.kind==="NumberLiteral")return Number(n.value)||t;const e=n.name?String(n.name):"",r=Number(e);return Number.isFinite(r)?r:t}function D(n,t,e,r){var v,F;const i=n.toLowerCase(),f=a=>C(a,e,r),b=a=>{const s=a?f(a):NaN;return Number.isFinite(s)?Math.max(0,s):0};if(i==="higherhigh"){const a=Math.max(1,Math.floor($(t[0],1))),s=g(r,"high"),c=Math.max(0,e-a),o=O(s,c,Math.max(0,e-1));return Number.isFinite(s[e])&&s[e]>o}if(i==="lowerlow"){const a=Math.max(1,Math.floor($(t[0],1))),s=g(r,"low"),c=Math.max(0,e-a),o=T(s,c,Math.max(0,e-1));return Number.isFinite(s[e])&&s[e]<o}if(i==="swinghigh"){const a=Math.max(1,Math.floor($(t[0],3))),s=g(r,"high"),c=s[e];if(!Number.isFinite(c))return!1;for(let o=e-a;o<=e+a;o++){if(o===e)continue;const h=s[o];if(Number.isFinite(h)&&h>=c)return!1}return!0}if(i==="swinglow"){const a=Math.max(1,Math.floor($(t[0],3))),s=g(r,"low"),c=s[e];if(!Number.isFinite(c))return!1;for(let o=e-a;o<=e+a;o++){if(o===e)continue;const h=s[o];if(Number.isFinite(h)&&h<=c)return!1}return!0}if(i==="volspike"){const a=Math.max(1,$(t[0],1)),s=g(r,"volume"),o=Math.max(0,e-20+1),h=(()=>{let u=0,m=0;for(let l=o;l<=e;l++){const p=s[l];Number.isFinite(p)&&(u+=p,m++)}return m?u/m:NaN})();return Number.isFinite(s[e])&&Number.isFinite(h)&&s[e]>a*h}if(i==="atrspike"){const a=Math.max(1,$(t[0],1)),s=g(r,"high"),c=g(r,"low"),o=g(r,"close"),h=14,u=N=>{const k=s[N],M=c[N],j=o[N-1];let x=Math.max(0,k-M);return Number.isFinite(j)&&(x=Math.max(x,Math.abs(k-j),Math.abs(M-j))),x};let m=NaN,l=0;for(let N=0;N<=e;N++){const k=u(N);l+=k,N===h-1?m=l/h:N>=h&&(m=(m*(h-1)+k)/h)}let p=NaN,w=0,y=0;for(let N=Math.max(0,e-h+1);N<=e;N++){const k=u(N);w+=k,y++}return p=y?w/y:NaN,Number.isFinite(m)&&Number.isFinite(p)&&m>a*p}if(i==="trend"){const a=String(((v=t[0])==null?void 0:v.name)||"").toLowerCase()||"up",s=g(r,"close"),o=Math.max(0,e-10+1),h=(()=>{let u=0,m=0,l=0,p=0,w=0;for(let N=o;N<=e;N++){const k=N-o,M=s[N];Number.isFinite(M)&&(u+=k,m+=M,l+=k*k,p+=k*M,w++)}const y=w*l-u*u;return y===0||w===0?0:(w*p-u*m)/y})();return a==="up"?h>0:h<0}if(i==="crossover"||i==="crossunder"){const a=t[0],s=t[1],c=b(t[2]),o=g(r,a.name||String(a));let h,u;if(s.kind==="NumberLiteral")h=s.value,u=s.value;else{const p=g(r,s.name||String(s));h=p[e-1],u=p[e]}const m=o[e-1],l=o[e];return[m,l,h,u].every(Number.isFinite)?i==="crossover"?m<=h+c&&l>u+c:m>=h-c&&l<u-c:!1}if(i==="rising"||i==="falling"){const a=g(r,((F=t[0])==null?void 0:F.name)||String(t[0])),s=Math.max(1,Math.floor($(t[1],3))),c=Math.max(0,e-s+1);let o=0,h=0,u=0,m=0,l=0;for(let y=c;y<=e;y++){const N=y-c,k=a[y];Number.isFinite(k)&&(o+=N,h+=k,u+=N*N,m+=N*k,l++)}const p=l*u-o*o,w=p===0||l===0?0:(l*m-o*h)/p;return i==="rising"?w>0:w<0}if(i==="above"||i==="below"){const a=f(t[0]),s=f(t[1]),c=b(t[2]);return!Number.isFinite(a)||!Number.isFinite(s)?!1:i==="above"?a>s+c:a<s-c}return!1}function E(n,t,e){switch(n.kind){case"Comparison":return R(n,t,e);case"Cross":return U(n,t,e);case"Logical":return _(n,t,e);case"Negation":return!E(n.expr,t,e);case"Between":{const r=n,i=C(r.value,t,e),f=C(r.a,t,e),b=C(r.b,t,e);if(![i,f,b].every(Number.isFinite))return!1;const v=Math.min(f,b),F=Math.max(f,b);return i>=v&&i<=F}case"Call":{const r=n;return D(String(r.name||""),r.args||[],t,e)}default:return!1}}function Z(n,t){const e=I(t),r=new Uint8Array(e);for(let i=0;i<e;i++)r[i]=E(n,i,t)?1:0;return r}function G(n){return n==="entry_long"||n==="exit_long"||n==="entry_short"||n==="exit_short"}self.onmessage=n=>{var F,a;const t=n.data,e=[],r=[];if(!t||!t.signals||!t.condSeries){const s={id:(t==null?void 0:t.id)||"unknown",signals:[],errors:["Invalid request"]};self.postMessage(s);return}const i=t.condSeries,f=t.bars||[],b=f.length||(((F=Object.values(i)[0])==null?void 0:F.length)??0);for(const s of t.signals){if(!G(String(s==null?void 0:s.type))){r.push(`Unknown signal type: ${String(s==null?void 0:s.type)}`);continue}const c=String((s==null?void 0:s.when)||"").trim();if(!c){r.push(`Empty condition for ${s.type}`);continue}let o;try{const u=c.replace(/\/\/.*$/,"").replace(/#.*$/,"").replace(/[,;]+\s*$/,"").replace(/\b(and|or)\b\s*$/i,"").replace(/\bcrosses\s+above\b/gi,"crossesAbove").replace(/\bcrosses\s+below\b/gi,"crossesBelow").trim();try{o=P(u)}catch{const l=u.match(/^(\w+)\s*(crossesAbove|crossesBelow)\s*(\w+|[-+]?\d+(?:\.\d+)?)$/i);if(l){const p=l[1],w=l[2],y=l[3],N=`${p} ${w==="crossesBelow"?"<":">"} ${y}`;o=P(N)}else o=P(u)}}catch(u){r.push(`Condition parse error for ${s.type}: ${(u==null?void 0:u.message)||String(u)}`);continue}let h;try{h=Z(o,i)}catch(u){r.push(`Condition eval error for ${s.type}: ${(u==null?void 0:u.message)||String(u)}`);continue}for(let u=0;u<b;u++)if(h[u]){const m=((a=f[u])==null?void 0:a.timestamp)??Date.now();e.push({type:s.type,index:u,timestamp:m})}}const v={id:t.id,signals:e,errors:r.length?r:void 0};self.postMessage(v)}})();
