var H=Object.defineProperty;var J=(F,S,j)=>S in F?H(F,S,{enumerable:!0,configurable:!0,writable:!0,value:j}):F[S]=j;var P=(F,S,j)=>J(F,typeof S!="symbol"?S+"":S,j);(function(){"use strict";const F=n=>n>="0"&&n<="9",S=n=>n>="a"&&n<="z"||n>="A"&&n<="Z"||n==="_"||n==="$";class j{constructor(t){P(this,"pos",0);this.input=t}next(){const t=this.input,e=t.length;for(;this.pos<e&&/\s/.test(t[this.pos]??"");)this.pos++;if(this.pos>=e)return{type:"eof",pos:this.pos};const r=this.pos,s=t[this.pos];if(F(s)||s==="."&&F(t[this.pos+1]??"")){let h=s===".";for(this.pos++;this.pos<e;){const u=t[this.pos];if(F(u))this.pos++;else if(u==="."&&!h)h=!0,this.pos++;else break}return{type:"number",value:t.slice(r,this.pos),pos:r}}if(S(s)){for(this.pos++;this.pos<e;){const v=t[this.pos];if(S(v)||F(v))this.pos++;else break}const h=t.slice(r,this.pos),u=h.toLowerCase();return u==="and"?{type:"and",pos:r}:u==="or"?{type:"or",pos:r}:u==="not"?{type:"not",pos:r}:u==="crossesabove"?{type:"crossesAbove",pos:r}:u==="crossesbelow"?{type:"crossesBelow",pos:r}:{type:"identifier",value:h,pos:r}}switch(this.pos++,s){case">":return t[this.pos]==="="?(this.pos++,{type:"gte",pos:r}):{type:"gt",pos:r};case"<":return t[this.pos]==="="?(this.pos++,{type:"lte",pos:r}):{type:"lt",pos:r};case"=":{if(t[this.pos]==="=")return this.pos++,{type:"eq",pos:r};throw new Error(`Unexpected '=' at ${r}, expected '=='`)}case"!":{if(t[this.pos]==="=")return this.pos++,{type:"neq",pos:r};throw new Error(`Unexpected '!' at ${r}, expected '!='`)}case"(":return{type:"lparen",pos:r};case")":return{type:"rparen",pos:r};case",":return{type:"comma",pos:r};default:throw new Error(`Unexpected character "${s}" at position ${r}`)}}}class A extends Error{constructor(t,e){super(t),this.position=e,this.name="ConditionParseError"}}class q{constructor(t){P(this,"current");this.tokenizer=t,this.current=t.next()}cur(){return this.current.type}eat(t){if(this.current.type!==t)throw new A(`Expected ${t} but found ${this.current.type}`,this.current.pos);const e=this.current;return this.current=this.tokenizer.next(),e}match(t){return this.current.type===t?(this.current=this.tokenizer.next(),!0):!1}parseCondition(){const t=this.parseOr();if(this.current.type!=="eof")throw new A("Unexpected input after end of condition",this.current.pos);return t}parseOr(){let t=this.parseAnd();for(;this.current.type==="or";){this.eat("or");const e=this.parseAnd();t={kind:"Logical",op:"or",left:t,right:e}}return t}parseAnd(){let t=this.parsePrimary();for(;this.current.type==="and";){this.eat("and");const e=this.parsePrimary();t={kind:"Logical",op:"and",left:t,right:e}}return t}parsePrimary(){if(this.current.type==="lparen"){this.eat("lparen");const t=this.parseOr();return this.eat("rparen"),t}if(this.current.type==="not")return this.eat("not"),{kind:"Negation",expr:this.parsePrimary()};if(this.current.type==="identifier"){const t=this.eat("identifier");if(this.cur()==="lparen"){this.eat("lparen");const u=[];if(this.cur()!=="rparen")for(;u.push(this.parseValue()),!!this.match("comma"););return this.eat("rparen"),String(t.value||"").toLowerCase()==="between"&&u.length===3?{kind:"Between",value:u[0],a:u[1],b:u[2]}:{kind:"Call",name:String(t.value||""),args:u}}const e={kind:"SeriesRef",name:String(t.value||"")};{const u=this.cur();if(u==="crossesAbove"||u==="crossesBelow"){const v=this.current;if(this.current=this.tokenizer.next(),e.kind!=="SeriesRef")throw new A("`crossesAbove/crossesBelow` left side must be a series name",v.pos);const d=this.parseValue();return{kind:"Cross",dir:v.type==="crossesAbove"?"above":"below",left:e,right:d}}}{const u=this.cur();if(u!=="gt"&&u!=="lt"&&u!=="gte"&&u!=="lte"&&u!=="eq"&&u!=="neq")return{kind:"Comparison",op:">",left:e,right:{kind:"NumberLiteral",value:0}}}const r=this.current;this.current=this.tokenizer.next();let s=">";r.type==="lt"?s="<":r.type==="gte"?s=">=":r.type==="lte"?s="<=":r.type==="eq"&&(s="==");const h=this.parseValue();return r.type==="neq"?{kind:"Logical",op:"or",left:{kind:"Comparison",op:">",left:e,right:h},right:{kind:"Comparison",op:"<",left:e,right:h}}:{kind:"Comparison",op:s,left:e,right:h}}return this.parseAtomCondition()}parseAtomCondition(){const t=this.parseValue();if(this.current.type==="crossesAbove"||this.current.type==="crossesBelow"){const u=this.current;if(this.current=this.tokenizer.next(),t.kind!=="SeriesRef")throw new A("`crossesAbove/crossesBelow` left side must be a series name",u.pos);const v=this.parseValue();return{kind:"Cross",dir:u.type==="crossesAbove"?"above":"below",left:t,right:v}}if(this.current.type!=="gt"&&this.current.type!=="lt"&&this.current.type!=="gte"&&this.current.type!=="lte"&&this.current.type!=="eq"&&this.current.type!=="neq")return{kind:"Comparison",op:">",left:t,right:{kind:"NumberLiteral",value:0}};const e=this.current;let r;switch(e.type){case"gt":r=">";break;case"lt":r="<";break;case"gte":r=">=";break;case"lte":r="<=";break;case"eq":r="==";break;case"neq":r="==";break;default:r=">";break}this.current=this.tokenizer.next();const s=this.parseValue(),h={kind:"Comparison",op:r,left:t,right:s};return e.type==="neq"?{kind:"Logical",op:"or",left:{kind:"Comparison",op:">",left:t,right:s},right:{kind:"Comparison",op:"<",left:t,right:s}}:h}parseSeriesRef(){if(this.current.type!=="identifier")throw new A("Expected series name",this.current.pos);const t=this.current;return this.current=this.tokenizer.next(),{kind:"SeriesRef",name:t.value||""}}parseValue(){if(this.current.type==="number"){const t=this.current;this.current=this.tokenizer.next();const e=Number(t.value);if(!Number.isFinite(e))throw new A("Invalid number literal",t.pos);return{kind:"NumberLiteral",value:e}}if(this.current.type==="identifier"){const t=this.current;if(this.current=this.tokenizer.next(),this.current.type==="lparen"){this.eat("lparen");const e=[];if(this.current.type!=="rparen")for(;e.push(this.parseValue()),!!this.match("comma"););return this.eat("rparen"),{kind:"ValueCall",name:String(t.value||""),args:e}}return{kind:"SeriesRef",name:String(t.value||"")}}throw new A(`Expected number or identifier but found ${this.current.type}`,this.current.pos)}}function B(n){return new q(new j(n)).parseCondition()}class z extends Error{constructor(t){super(t),this.name="ConditionEngineError"}}function R(n){return n.replace(/\s+/g,"_").toLowerCase()}function k(n,t){const e=R(t),r=n[e];if(r)return r;const s=e.replace(/_/g,"");if(s&&n[s])return n[s];if(s){const u=Object.keys(n).find(v=>v.replace(/_/g,"")===s);if(u&&n[u])return n[e]=n[u],n[e]}const h=Object.keys(n).slice(0,24).join(", ");throw new z(`Series "${t}" not found; available series: ${h}${Object.keys(n).length>24?", ...":""}`)}function O(n){const t=Object.entries(n);if(!t.length)return 0;const e=t[0][1].length;for(const[,r]of t)if(r.length!==e)throw new z("All series must have the same length");return e}function C(n,t,e){var r,s,h,u,v,d;if(n.kind==="NumberLiteral")return n.value;if(n.kind==="SeriesRef")return k(e,n.name)[t];if(n.kind==="ValueCall"){const a=String(n.name||"").toLowerCase(),o=n.args;if(a==="lowest"||a==="highest"){const i=o[0],c=o[1],f=k(e,i.name||String(i)),b=Math.max(1,Math.floor(c.value??Number(c.name)??1)),m=Math.max(0,t-b+1);let l=a==="lowest"?1/0:-1/0;for(let N=m;N<=t;N++){const w=f[N];Number.isFinite(w)&&(a==="lowest"?l=Math.min(l,w):l=Math.max(l,w))}return Number.isFinite(l)?l:NaN}if(a==="lag"||a==="prev"){const i=o[0],c=o[1],f=k(e,i.name||String(i)),b=Math.max(1,Math.floor((c==null?void 0:c.value)??Number(c==null?void 0:c.name)??1)),m=t-b;return m>=0?f[m]:NaN}if(a==="change"){const i=o[0],c=o[1],f=k(e,i.name||String(i)),b=Math.max(1,Math.floor((c==null?void 0:c.value)??Number(c==null?void 0:c.name)??1)),m=t-b,l=f[t],N=m>=0?f[m]:NaN;return Number.isFinite(l)&&Number.isFinite(N)?l-N:NaN}if(a==="abs"){const i=C(o[0],t,e);return Math.abs(i)}if(a==="add"||a==="sub"||a==="mul"||a==="div"){const i=C(o[0],t,e),c=C(o[1],t,e);return[i,c].every(Number.isFinite)?a==="add"?i+c:a==="sub"?i-c:a==="mul"?i*c:c===0?NaN:i/c:NaN}if(a==="min"||a==="max"){const i=C(o[0],t,e),c=C(o[1],t,e);return[i,c].every(Number.isFinite)?a==="min"?Math.min(i,c):Math.max(i,c):NaN}if(a==="sma"){const i=((r=o[0])==null?void 0:r.name)||String(o[0]),c=((s=o[1])==null?void 0:s.value)??Number((h=o[1])==null?void 0:h.name),f=Math.max(1,Math.floor(Number(c)||0)),b=k(e,i);if(!Number.isFinite(b[t]))return NaN;let m=0,l=0;const N=Math.max(0,t-f+1);for(let w=N;w<=t;w++){const p=b[w];Number.isFinite(p)&&(m+=p,l++)}return l?m/l:NaN}if(a==="ema"){const i=((u=o[0])==null?void 0:u.name)||String(o[0]),c=((v=o[1])==null?void 0:v.value)??Number((d=o[1])==null?void 0:d.name),f=Math.max(1,Math.floor(Number(c)||0)),b=k(e,i),m=2/(f+1);let l;for(let N=0;N<=t;N++){const w=b[N];Number.isFinite(w)&&(l===void 0?l=w:l=w*m+l*(1-m))}return l??NaN}return NaN}return NaN}function _(n,t,e){const r=C(n.left,t,e),s=C(n.right,t,e);if(!Number.isFinite(r)||!Number.isFinite(s))return!1;switch(n.op){case">":return r>s;case"<":return r<s;case">=":return r>=s;case"<=":return r<=s;case"==":return Math.abs(r-s)<1e-9;default:return!1}}function I(n,t,e){if(t===0)return!1;const r=k(e,n.left.name);let s,h;if(n.right.kind==="NumberLiteral")s=n.right.value,h=n.right.value;else{const d=k(e,n.right.name);s=d[t-1],h=d[t]}const u=r[t-1],v=r[t];return!Number.isFinite(u)||!Number.isFinite(s)||!Number.isFinite(v)||!Number.isFinite(h)?!1:n.dir==="above"?u<=s&&v>h:u>=s&&v<h}function M(n,t,e){return n.op==="and"?E(n.left,t,e)&&E(n.right,t,e):E(n.left,t,e)||E(n.right,t,e)}function U(n,t,e){let r=-1/0;for(let s=t;s<=e;s++){const h=n[s];Number.isFinite(h)&&h>r&&(r=h)}return r}function T(n,t,e){let r=1/0;for(let s=t;s<=e;s++){const h=n[s];Number.isFinite(h)&&h<r&&(r=h)}return r}function L(n,t=1){if(!n)return t;if(n.kind==="NumberLiteral")return Number(n.value)||t;const e=n.name?String(n.name):"",r=Number(e);return Number.isFinite(r)?r:t}function D(n,t,e,r){var v,d;const s=n.toLowerCase(),h=a=>C(a,e,r),u=a=>{const o=a?h(a):NaN;return Number.isFinite(o)?Math.max(0,o):0};if(s==="higherhigh"){const a=Math.max(1,Math.floor(L(t[0],1))),o=k(r,"high"),i=Math.max(0,e-a),c=U(o,i,Math.max(0,e-1));return Number.isFinite(o[e])&&o[e]>c}if(s==="lowerlow"){const a=Math.max(1,Math.floor(L(t[0],1))),o=k(r,"low"),i=Math.max(0,e-a),c=T(o,i,Math.max(0,e-1));return Number.isFinite(o[e])&&o[e]<c}if(s==="swinghigh"){const a=Math.max(1,Math.floor(L(t[0],3))),o=k(r,"high"),i=o[e];if(!Number.isFinite(i))return!1;for(let c=e-a;c<=e+a;c++){if(c===e)continue;const f=o[c];if(Number.isFinite(f)&&f>=i)return!1}return!0}if(s==="swinglow"){const a=Math.max(1,Math.floor(L(t[0],3))),o=k(r,"low"),i=o[e];if(!Number.isFinite(i))return!1;for(let c=e-a;c<=e+a;c++){if(c===e)continue;const f=o[c];if(Number.isFinite(f)&&f<=i)return!1}return!0}if(s==="volspike"){const a=Math.max(1,L(t[0],1)),o=k(r,"volume"),c=Math.max(0,e-20+1),f=(()=>{let b=0,m=0;for(let l=c;l<=e;l++){const N=o[l];Number.isFinite(N)&&(b+=N,m++)}return m?b/m:NaN})();return Number.isFinite(o[e])&&Number.isFinite(f)&&o[e]>a*f}if(s==="atrspike"){const a=Math.max(1,L(t[0],1)),o=k(r,"high"),i=k(r,"low"),c=k(r,"close"),f=14,b=g=>{const y=o[g],$=i[g],x=c[g-1];let V=Math.max(0,y-$);return Number.isFinite(x)&&(V=Math.max(V,Math.abs(y-x),Math.abs($-x))),V};let m=NaN,l=0;for(let g=0;g<=e;g++){const y=b(g);l+=y,g===f-1?m=l/f:g>=f&&(m=(m*(f-1)+y)/f)}let N=NaN,w=0,p=0;for(let g=Math.max(0,e-f+1);g<=e;g++){const y=b(g);w+=y,p++}return N=p?w/p:NaN,Number.isFinite(m)&&Number.isFinite(N)&&m>a*N}if(s==="trend"){const a=String(((v=t[0])==null?void 0:v.name)||"").toLowerCase()||"up",o=k(r,"close"),c=Math.max(0,e-10+1),f=(()=>{let b=0,m=0,l=0,N=0,w=0;for(let g=c;g<=e;g++){const y=g-c,$=o[g];Number.isFinite($)&&(b+=y,m+=$,l+=y*y,N+=y*$,w++)}const p=w*l-b*b;return p===0||w===0?0:(w*N-b*m)/p})();return a==="up"?f>0:f<0}if(s==="crossover"||s==="crossunder"){const a=t[0],o=t[1],i=u(t[2]),c=k(r,a.name||String(a));let f,b;if(o.kind==="NumberLiteral")f=o.value,b=o.value;else{const N=k(r,o.name||String(o));f=N[e-1],b=N[e]}const m=c[e-1],l=c[e];return[m,l,f,b].every(Number.isFinite)?s==="crossover"?m<=f+i&&l>b+i:m>=f-i&&l<b-i:!1}if(s==="rising"||s==="falling"){const a=k(r,((d=t[0])==null?void 0:d.name)||String(t[0])),o=Math.max(1,Math.floor(L(t[1],3))),i=Math.max(0,e-o+1);let c=0,f=0,b=0,m=0,l=0;for(let p=i;p<=e;p++){const g=p-i,y=a[p];Number.isFinite(y)&&(c+=g,f+=y,b+=g*g,m+=g*y,l++)}const N=l*b-c*c,w=N===0||l===0?0:(l*m-c*f)/N;return s==="rising"?w>0:w<0}if(s==="above"||s==="below"){const a=h(t[0]),o=h(t[1]),i=u(t[2]);return!Number.isFinite(a)||!Number.isFinite(o)?!1:s==="above"?a>o+i:a<o-i}return!1}function E(n,t,e){switch(n.kind){case"Comparison":return _(n,t,e);case"Cross":return I(n,t,e);case"Logical":return M(n,t,e);case"Negation":return!E(n.expr,t,e);case"Between":{const r=n,s=C(r.value,t,e),h=C(r.a,t,e),u=C(r.b,t,e);if(![s,h,u].every(Number.isFinite))return!1;const v=Math.min(h,u),d=Math.max(h,u);return s>=v&&s<=d}case"Call":{const r=n;return D(String(r.name||""),r.args||[],t,e)}default:return!1}}function K(n,t){const e=O(t),r=new Uint8Array(e);for(let s=0;s<e;s++)r[s]=E(n,s,t)?1:0;return r}function Z(n){return n==="entry_long"||n==="exit_long"||n==="entry_short"||n==="exit_short"}self.onmessage=n=>{var d,a;const t=n.data,e=[],r=[];if(!t||!t.signals||!t.condSeries){const o={id:(t==null?void 0:t.id)||"unknown",signals:[],errors:["Invalid request"]};self.postMessage(o);return}const s=t.condSeries,h=t.bars||[],u=h.length||(((d=Object.values(s)[0])==null?void 0:d.length)??0);for(let o=0;o<t.signals.length;o++){const i=t.signals[o];if(!Z(String(i==null?void 0:i.type))){r.push(`Unknown signal type: ${String(i==null?void 0:i.type)}`);continue}const c=String((i==null?void 0:i.id)||o),f=String((i==null?void 0:i.when)||"").trim();if(!f){r.push(`Empty condition for ${i.type}`);continue}let b;try{const p=f.replace(/\/\/.*$/,"").replace(/#.*$/,"").replace(/[,;]+\s*$/,"").replace(/\b(and|or)\b\s*$/i,"").replace(/\bcrosses\s+above\b/gi,"crossesAbove").replace(/\bcrosses\s+below\b/gi,"crossesBelow").trim();try{b=B(p)}catch{const y=p.match(/^(\w+)\s*(crossesAbove|crossesBelow)\s*(\w+|[-+]?\d+(?:\.\d+)?)$/i);if(y){const $=y[1],x=y[2],V=y[3],G=`${$} ${x==="crossesBelow"?"<":">"} ${V}`;b=B(G)}else b=B(p)}}catch(p){r.push(`Condition parse error for ${i.type}: ${(p==null?void 0:p.message)||String(p)}`);continue}let m;try{m=K(b,s)}catch(p){r.push(`Condition eval error for ${i.type}: ${(p==null?void 0:p.message)||String(p)}`);continue}const l=i==null?void 0:i.cooldownBars,N=typeof l=="number"&&Number.isFinite(l)?Math.max(0,Math.floor(l)):0;let w=0;for(let p=0;p<u;p++){if(N>0&&p<w||!m[p])continue;const g=((a=h[p])==null?void 0:a.timestamp)??Date.now();e.push({type:i.type,index:p,timestamp:g,signalId:c}),N>0&&(w=p+N)}}const v={id:t.id,signals:e,errors:r.length?r:void 0};self.postMessage(v)}})();
